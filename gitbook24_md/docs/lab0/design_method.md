# 设计方法

## 硬件描述语言简介

硬件描述语言之所以被称为硬件描述语言而不是硬件设计语言, 其原因在于, 硬件描述语言的本质是对实际电路的一种描述, 学习时应注意区别于软件编程语言(对过程的一种描述). 描述数字电路的硬件描述语言中被广泛使用的主要有 VHDL, Verilog, SystemVerilog. 

> #### fread::有关 SystemVerilog
>
> SystemVerilog 是一种由 Verilog 发展而来的硬件描述、硬件验证统一语言, 前一部分基本上是 2005 年版 Verilog 的扩展, 而后一部分功能验证特性则是一门面向对象程序设计语言. 面向对象特性很好地弥补了传统 Verilog 在芯片验证领域的缺陷, 改善了代码可重用性, 同时可以让验证工程师在比寄存器传输级更高的抽象级别, 以事务而非单个信号作为监测对象, 这些都大大提高了验证平台搭建的效率. 

为了描述复杂的硬件电路, 设计者通常将复杂的功能划分为简单的功能, 实现简单的功能模块后将其连接实现复杂的功能, 这便是“自顶向下”的设计思想, 与之相对的也有“自底向上”的设计思想, 一般电路设计都是采用“自顶向下”的思想完成的. 

抽象是硬件设计的一个重要思想, 简单来说, 引入抽象的目的在于, 高抽象层次的设计者不用过分关心低抽象层次的设计细节, 比如, 我们在用硬件描述语言描述我们设计的电路时并不需要过分关心电路使用 CMOS 还是 TTL, 也不需要首要考虑芯片使用的工艺, 主要关心的是电路的功能是否正确. 

对于描述数字电路的硬件描述语言来说, 最低的抽象层次便是开关级, 通过描述晶体管开关网表来描述一个电路. 稍微高一层的抽象层次是门级, 通过描述逻辑门之间的连接关系描述电路. 不管是开关级描述, 还是门级描述, 都可以被归类到结构化描述中, 因为它们都属于对电路元件连接结构的一种描述. 比结构化描述更高一层的是对电路功能的描述, 通常包括数据流描述(一般指对进行逻辑运算的组合逻辑的描述), 寄存器传输级描述(RTL, Register Transfer Level), 通过描述信号在寄存器之间的流动来描述电路. 最高抽象层次为行为级描述, 通过抽象的结构(如循环)描述电路的行为来描述电路, 也包括使用算术运算(如加法和乘法)来描述电路的算术行为. 

>#### note::行为级描述和 RTL 描述
>
>如果你要设计一个下图所示的二选一选择器, 
>
><div align ="center"><img src="/img/lab0/11.png" alt="选择器" style="zoom:100%;" /><div align ="center">
>
>使用行为级描述为:
>
>```verilog
>if  (sel) 
>    c <= a;
>else 
>    c <= b;  
>```
>
>使用 RTL 描述为
>
>```verilog
>assign c = sel ? a : b; 
>```
>
>行为级描述一般比较易于理解, RTL 则是直接描述电路功能. 需要注意的是, 行为级描述并不是任何时候都可以用于[综合](#基于硬件描述语言的设计方法).

<!--  -->

>#### note::硬件描述语言和常见的软件设计使用语言(如 C 语言)的区别
>
>硬件描述语言具有空间上的并行性, 在每一个模块是按照空间分布并行执行的; 而软件设计所使用的语言则是按照时间顺序, 根据 CPU 的时钟扫描执行的. 硬件描述语言本质上是对电路的描述. 

## 基于硬件描述语言的设计方法

在基于硬件描述语言的设计流程中, 最重要的是逻辑综合(logic synthesis)技术. 逻辑综合技术最早出现于上世纪80年代中期, 它接受 RTL 级描述和一些人为添加的时序约束输入, 将 RTL 级描述转换成寄存器和逻辑运算表达式, 通过一系列的优化算法, 最终生成满足时序约束的门级网表.

这种设计流程有很多优势, 首先, 因为 RTL 级描述相比于门级电路来说更容易被理解, 也更容易找出错误, 其次, 逻辑仿真器对 RTL 级描述进行功能仿真比对门级描述进行仿真快很多, 可以更快地发现错误, 设计者的生产效率大大提高. 一旦逻辑综合工具生成了门级网表, 之后的流程便和手画电路的 ASIC 设计流程非常类似. 门级网表可以用于进一步的仿真验证, 也可以用于时序分析. 网表在输入到布局布线工具中后, 可以通过提取到更准确的电路参数进行更加准确的时序分析. 在 FPGA 上实现时, 流程非常类似. 与 ASIC 设计不同之处在于, 针对 ASIC 的逻辑综合工具综合出的网表是描述逻辑门和寄存器的连接关系. 而FPGA中的基本结构为查找表, 因此FPGA厂商还需要开发映射(mapping)、打包(packing)、布局布线(place-and-route)等功能. 随着技术的发展, 综合工具已经能够输出 LUT/CLB 级网表到布局布线工具.

> #### fread::有关逻辑综合
>
> 逻辑综合是芯片的前端设计和后端实现的分水岭. 综合的过程是将抽象程度较高的 RTL 代码转换到与工艺库相关的门级网表的过程. 逻辑综合可以决定设计的门级结构. 简单来说, 综合就是将代码转换为电路的过程.
>
> 逻辑综合分为三个阶段, 转译, 优化和映射. 转译是将代码转换为一个和工艺库无关的门级电路; 优化是根据设计人员添加的约束将转译后生成的门级电路优化成满足设计指标要求的门级网表; 映射是把优化之后的门级网表转换成对应给定的工艺库的门级网表.

## 高层次综合(HLS)

随着片上系统复杂性的不断提高, 促使工业界将硬件设计的抽象级别进一步提高. 尽管在上世纪 80 年代初便有关于高层次综合(HLS)技术的研究, 并且于 90 年代推出了一些商业工具, 但直到最近几年, 高层次综合(HLS)设计方法才取得了一定的成果, 被 IC 设计公司更多地应用于实际开发工作. HLS 之所以在研究初期并未取得成功, 主要有以下几点原因:

1.  缺乏全面的设计语言支持: 第一代 HLS 综合工具无法综合高级编程语言. 而是使用未定时或部分定时的行为 HDL. 这样的设计虽然在某种程度上提高了抽象水平, 但同时对软件和硬件开发人员都施加了陡峭的学习曲线. 尽管早期的基于 C 的 HLS 技术已经大大提高了易用性和设计抽象水平, 但是许多基于 C 的工具仍然存在明显的缺陷. 
2.  缺乏可重复使用和可移植的设计规范: 许多 HLS 工具要求用户将详细的时序和接口信息以及综合约束嵌入到源代码中. 这样做的结果就是, 功能规范变得高度依赖于工具, 依赖于目标或实现平台. 因此, 它不容易移植重用. 
3. 只关注数据路径综合: 许多 HLS 工具只关注数据路径综合, 而其他重要方面则无人关注, 例如与其他硬件/软件模块的接口和平台集成. 因此, 解决系统集成问题成为关键的设计瓶颈, 从而限制了在设计中向 IP 过渡到更高级别的抽象层次. 
4.  缺乏令人满意的结果: 当从 1990 年代中期到 2000 年代初期引入早期 HLS 工具时, EDA 行业仍在逻辑与物理设计之间的时序收敛问题上苦苦挣扎. 没有可靠的RTL 到 GDSII 基础来支持 HLS, 这使得难以一致地测量, 跟踪和优化 HLS 结果. 高度自动化的 RTL 到 GDSII 解决方案仅在 2000年代后期才可用. 此外, 许多 HLS 工具在优化现实的设计指标方面都很弱. 
5. 令人信服的理由: 第一代 HLS 工具显然领先于时代, 因为 RTL 在 1990 年代后期仍然可以胜任当时设计的复杂程度. 尽管第二代 HLS 工具提高了设计抽象层次, 但大多数设计人员仍不愿冒险摆脱熟悉的 RTL 设计方法, 而接受一种未经验证的新方法, 尽管它具有潜在的巨大优势. 像 EDA 行业中的任何重大转变一样, 设计师需要一个令人信服的理由来促使他们采用新的设计方法, 即 HLS. 

<div align ="center"><img src="/img/lab0/01.png" alt="HLS设计流程" style="zoom:100%;" /><div align ="center">

上图为 Xilinx 公司的使用 HLS 进行 FPGA 开发的设计流程. AutoPilot 接受可综合的 ANSI C, C++或SystemC 作为输入, 综合输出 RTL 级 HDL 代码用于仿真验证. 除了综合出 RTL 级 HDL 代码外, AutoPilot 也输出包含 FPGA 资源利用率、时序延迟等信息的综合报告. 最后, 生成的 HDL 文件被 Xilinx 工具用于综合实现, 生成比特流下载到 FPGA 中. 

最新一代的 FPGA HLS 工具在提供广泛的语言覆盖范围, 强大的编译技术, 基于平台的建模以及特定域的系统级集成方面取得了重大进展. 结果, 它们可以快速提供很好的结果, 在很多情况下, 这些结果与手动 RTL 设计相比差不多甚至更好. 

虽然 HLS 技术取得了一定的成功, 但是仍然存在许多值得优化的地方. 在处理大量数据或高数据速率的应用中, 片外存储器的综合支持非常重要, 但是现有的大多数 HLS 工具对这方面的支持不够好. 另外, 片上和板级设计验证与调试已成为基于 FPGA 的系统开发最耗时的方面之一, 尤其是在电路规模不断增加且设计复杂性不断提高的情况下. 尽管 HLS 保证了大多数验证都可以通过执行原始的非定时C语言模型来执行, 但是板上出现的与时序和数据相关的错误通常很难调试. 当前, 检测此类错误的常见做法是执行 RTL 级时序精确仿真或使用主要供应商提供的系统内调试工具(如 Intel FPGA 的 SignalTap 和 Xilinx 的 ChipScope). 这些工具可用于插入逻辑分析仪内核, 并提供触发和探测 FPGA 电路内部信号的功能. 在板级验证与调试方面, HLS 技术还有很大的发展空间. 

>#### question::Why not C?
>
>我们为什么不能用 C 语言来直接设计 SoC? 如果要使用的话应该怎样使用?

