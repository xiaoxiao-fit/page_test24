# FPGA简介

## 什么是FPGA？

FPGA 中文名是可编程逻辑门阵列,  英文全称是 Field Programmable Gate Arrays , 是一种包含由可配置的互连线进行互连的可编程逻辑块的数字集成电路. 设计者可以通过编程对 FPGA 进行配置, 实现不同的电路功能. 

上世纪 80 年代中期 FPGA 刚问世时, 它通常被用于中等复杂度状态机的实现, 或者一些受限的数据处理任务. 在 90 年代早期, 随着 FPGA 的规模和复杂程度的提高，它们的应用场景通常是通信和网络领域里的更加复杂的信号处理任务. 到了 90 年代后期, FPGA 在定制化、自动化及部分工业应用中占的比重越来越大. 

FPGA 通常用于专用集成电路(ASIC)的原型设计，也是一种用于验证算法实现的硬件平台. 但是，FPGA 的低成本和开发快捷两大特点意味着 FPGA 在输出产品时有着 ASIC 所不能比拟的优势.  进入 21 世纪以后, 出现包含有百万级门电路的高性能 FPGA, 这类 FPGA 一般用于实现嵌入式微处理器核, 高速 IO 接口等电路, 并且 FPGA 的规模和性能都在飞速发展. 最终结果是现在的 FPGA 可以用来实现几乎所有可以用 ASIC 实现的功能, 包括通信设备, 数字信号处理器(DSP), 片上系统(SoC). 

> #### fread::什么是 asic? 
>
> asic,全程Application Specific Integrated Circuit,中文名为专用集成电路, 是一种依产品需求不同而全定制的特殊规格集成电路.
>
> 了解更多:
>
> * [关于asic](https://zh.wikipedia.org/wiki/%E7%89%B9%E6%AE%8A%E6%87%89%E7%94%A8%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF) 
>
> * [asic和其他芯片有什么不同?](http://www.elecfans.com/d/672204.html)

FPGA 通常被用来与 ASIC 进行比较, 与 ASIC 相比, FPGA 更加灵活, ASIC 一旦流片便无法修改, 并且一次流片费用高昂, 一般人难以承受; 而 FPGA 是可编程的, 如果发现功能不对, 便可以通过再一次编程配置的方式进行修改. 但是, 通常来说, FPGA 比同种工艺下的 ASIC 性能差, 这就需要设计者在性能和灵活性上做一定的取舍. 

> #### note::一种关于 FPGA 和  ASIC 的庸俗化理解
>
> 可以认为 FPGA 相当于积木, ASIC 相当于模型, 使用积木时,可以随心所欲地搭建你想要的东西(可以理解为 FPGA 的可编程性); 而一个模型做出来之后(类似于 asic 流片之后) 想要再次 diy 就是一件很困难的事, 如果你想要新的玩法, 最好的方法是再买一个(如果你能承受昂贵的费用的话).

## FPGA的基本结构

FPGA 之所以是可编程的, 是因为 FPGA 的基本逻辑单元可以通过配置实现不同的逻辑功能, 且 FPGA 内部逻辑单元之间的互连线也可以通过配置实现基本逻辑功能的扩展. 在 Xilinx FPGA 中, 基本逻辑单元一般被称为 LC(logic cell), 一个 LC 一般由一个查找表(LUT)、 一个多路复用器(MUX)和一个寄存器组成, 其中 LUT 也可以是一个 RAM 或者移位寄存器(SR), 如下图所示. 

<div align ="center"><img src="/img/lab0/02.png" alt="fpga基本逻辑单元" style="zoom:120%;" /><div align ="center">


<center style="color:#000000;font-size:10pt;">FPGA 基本逻辑单元</center>

除了查找表、多路复用器和寄存器之外, 一个基本的逻辑单元一般还会包括一些特殊的快速进位单元用于算术操作.

有了基本的逻辑单元以后，使用两个基本逻辑单元 LC 便可构成一个 Slice(在安路FPGA 中四个 LC 构成的单元被称为 slice, 在 Intel FPGA 中有另外的名称). 通过逻辑单元的组合可以起到扩展功能的作用. 值得一提的是, 在一个 slice 中虽然每一个逻辑单元有独立的查找表、多路复用器, 但是每个 slice 内部的各逻辑单元都使用同一个时钟和使能信号. 

由多个 slice(一般为 2 个或 4 个) 可以组成 安路 FPGA 中的基本可配置逻辑块(Configurable Logic Block，CLB), 在 Intel FPGA中一般称为逻辑阵列块(Logic Array Block，LAB).

在 FPGA 中, 各个基本可配置逻辑块(CLB)是通过可配置的互连线相互连接的. 从最基本的逻辑单元 LC 到两个基本逻辑单元 LC 组成的 slice 单元再到 2 个或 4 个 slice 组成的基本可配置逻辑块(CLB), 这一级又一级的组成层次, 实际是由互连的层次结构决定的. 在 slice 单元里的两个逻辑单元 LC 之间的互连是很快的, 到基本可配置逻辑块(CLB) 内的几个 slice 单元之间的互连时, 速度便有了明显的下降. 这种层次结构本质上是互连的便捷性和延迟(速度) 的一种权衡取舍. 

由于绝大多数应用都需要使用存储单元进行数据存储, 所以 FPGA 中需要存储单元, 如果用 CLB 来实现存储, 将会导致大量的资源浪费, 所以一般采用在 FPGA 结构中放置 RAM 单元的方法实现存储功能. 这种放置在 FPGA 结构中的 RAM 在 Xilinx FPGA 中一般称为 Block RAM, 每个 Block RAM 既可以独立使用, 也可以被组织成任意位宽的 RAM, 还可以用于实现异步 FIFO.

绝大多数的算术单元如果使用LUT来实现将会非常浪费资源, 为了解决这类问题, 在 FPGA 中一般会嵌入一些算术操作单元, 如乘累加(MAC), 或者嵌入数字信号处理器(Digital Signal Processor, DSP). 一般 DSP 可以实现 MAC, FIR 滤波, 开根等操作, 所以利用FPGA中的DSP块进行复杂算术操作将会非常方便并且节省资源.

除了上述资源外, 部分 FPGA 中嵌入了硬核微处理器, 将在下一节具体介绍. 另外, FPGA 中有大量的 I/O 端口, 方便与外界电路通信, 但即便如此, I/O 端口的数量依旧是一个瓶颈, 随着逻辑逐渐复杂, 所需的 I/O 端口越来越多, 但 FPGA 更新时, I/O 端口的数量增加得很少.

FPGA 中的时钟信号由外部世界产生, 并连到合适的寄存器上. 在 FPGA 内部有一个时钟树结构, 该结构用于确保所有的触发器接收到的时钟信号尽可能的一致, 如果没有时钟树结构的存在, 由于时钟信号到各个寄存器的距离不同, 延迟不同, 各触发器接收到的时钟信号便会有一定的偏差. 离时钟信号最近的寄存器将会更早被触发, 这种现象被称为时钟偏斜(skew), 可能引起一系列更严重的问题.

## 微处理器 + FPGA 

几乎所有的逻辑功能都可以用硬件或软件实现, 其中硬件主要指使用逻辑门和寄存器等, 软件主要指可以被处理器执行的一条条指令. 硬件实现和软件实现是需要权衡取舍的两种实现方法, 使用硬件实现虽然速度更快, 但灵活性差; 使用软件实现虽然灵活性更好, 但是速度通常慢于直接使用硬件实现. 所以, 为了在运行速度和灵活性之间做权衡取舍, 很多时候需要软硬件协同设计的思想来指导设计, 利用软件实现控制功能, 而硬件实现计算, 当然, 在硬件实现计算时通常也需要考虑硬件的并行性能否很好地加速计算的问题.

由于 FPGA 的灵活性, 近年来有很多利用FPGA对复杂运算进行加速的应用, 比如在 FPGA 平台上实现卷积神经网络(CNN) 加速,通常由主机控制数据搬运过程, 由 FPGA 上实现的加速电路进行运算.

既然 FPGA 作为一种特殊的数字电路, 通过下载不同设计的比特流, 便可以配置成各种不同功能的电路. 所以, FPGA 厂商在部分 FPGA 中嵌入了微处理器硬核, 开发者便可以通过编写软件程序利用微处理器的强大控制能力, 也可以利用FPGA的灵活性, 实现更复杂的功能的同时拥有更强的性能.

微处理器硬核被视为一个“黑盒”嵌入 FPGA 中, 通常有两种方式, 第一种是和 RAM, I/O 口等电路部分作为一个整体, 不放在 FPGA 的主阵列中. 在这种方式下, 所有的器件都被封装在同一硅片上. 主要的 FPGA 部分依然包括嵌入的 RAM、乘法器等模块. 这种实现方式的一大优势在于主要的 FPGA 结构实现与嵌入式微处理器硬核实现无关, 这样便可以使设计工具更加简单, 另一大优势在于 FPGA 厂商可以打包一些额外的功能，用主要FPGA结构之外的部分(如微处理器、RAM 等模块) 实现.

另一种在 FPGA 中嵌入硬核的方法便是直接将其嵌入FPGA的主要结构中. 同样, 主要的 FPGA 部分包括嵌入的 RAM、乘法器等模块. 这样, 所有的存储单元都可以使用嵌入的 RAM 模块，任意外设功能都可以用可编程逻辑块实现, 另外, 将微处理器硬核嵌入 FPGA 中还有一定的速度优势.

> #### note::一个例子帮你理解 FPGA 和微处理器的区别
>
> 当你打算用一个开关去控制一个 LED 灯时, 如果使用嵌入式进行控制, 你需要编写软件代码到微处理器中, 之后微处理器会不断地扫描检测开关是否打开, 然后给 LED 灯发出是否点亮的指令; 如果使用 FPGA 进行控制, 你只需要利用硬件描述语言(VHDL 或者 Verilog HDL) 把开关和 LED 灯用一根线连起来就可以了. 